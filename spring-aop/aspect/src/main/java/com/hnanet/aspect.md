## 静态代理&动态代理 的缺点
```text
    静态代理：静态代理的重用性太差，一个代理不能同事代理多种类；
    动态代理（JDK代理、CGLIB代理）：动态代理可以做到代理的重用，但调用起来还是比较麻烦，除了写切面代码以外，我们还需要将代理类耦合进被代理类的调用阶段，在创建被代理类的时候都要先创建代理类，再用代理类去创建被代理类
    这种麻烦出现的本质原因是，代理模式并没有做到切面与业务代码的解耦。虽然将切面的逻辑独立进了代理类，但是"决定是否使用切面的权利"仍然在业务代码中。这才导致了上面这种麻烦。
```

## Spring AOP
```text
    Spring的IoC容器，将类的创建都统一托管起来，我们只需要将切面用配置文件进行注册，容器会根据注册信息在创建bean的时候自动加上代理。
```

## AspectJ
```text
AspectJ提供了两个东西：
    切面语法：将是否使用切面的权利还给了切面，在写代码的时候就决定那些类的哪些方法会被代理，从而从逻辑上不需要入侵业务代码。
    织入工具：
            一种就是提供注册机制，通过额外的配置文件指明哪些类受到切面的影响，不过这还是需要干涉对象创建的过程；
            另外一种解决思路就是在编译期(或者类加载期)我们优先考虑一下切面代码，并将切面代码通过某种形式插入到业务代码中，这种实现就是 aspectjweaver。
```

## Spring AOP vs AspectJ
```text
    在 Spring AOP 中，我们只有调用代理类的切点方法才能触发 Before 方法，因为代理类本质上是对原类的一层封装，原类是没有变化的，原类的方法内部的this指向的依旧是原类，这就导致了原类方法内部的嵌套调用无法被代理类感知到
    而 AspectJ 是通过织入的方式将切面代码织入进原对象内部，并不会生成额外的代理类。AspectJ 的织入它会动态改变你的原类代码，将Before等方法全部写入进你的原方法中，这就保证了面向切面编程的万无一失。
```